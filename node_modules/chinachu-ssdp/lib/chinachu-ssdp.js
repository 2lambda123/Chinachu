/*!
 *  Chinachu SSDP Module (node-chinachu-ssdp)
 *
 *  Copyright (c) 2013 Yuki KAN and Chinachu Project Contributors
 *  http://chinachu.akkar.in/
 *
 *  forked from: node-ssdp by Nicholas Libby
 *  http://www.xedecimal.net/
 *  https://bitbucket.org/Xedecimal
 *  https://bitbucket.org/Xedecimal/node-ssdp
**/

var os     = require('os');
var dgram  = require('dgram');
var events = require('events');
var util   = require('util');

var ssdp = {
	ip  : '239.255.255.250',
	port: 1900,
	uuid: '49ee272d-f140-4cf0-a8cf-b7caa23ff772'
};

ssdp.ipport = ssdp.ip + ':' + ssdp.port;
ssdp.sig    = 'uuid:' + ssdp.uuid;

function SSDP() {
	if (!(this instanceof SSDP)) return new SSDP();
	
	events.EventEmitter.call(this);
	
	this.header = {
		host  : ssdp.ipport,
		cache : 'max-age=30',
		server: [os.platform() + '/' + os.release(), 'UPnP/1.0', 'Chinachu-SSDP/beta'].join(' ')
	};
	
	this.usn = {};
	
	// Configure socket for either client or server.
	this.sock = dgram.createSocket('udp4');
	
	this.sock.on('error', function () {
		util.log('############### Got an error!');
	});
	
	this.sock.on('message', function onMessage(msg, rInfo) {
		
		this.parseMessage(msg, rInfo);
	}.bind(this));
	
	this.sock.on('listening', function onListening() {
		
		var addr = this.sock.address();
		
		util.log('SSDP Listening on ' + addr.address + ':' + addr.port);
		
		this.sock.addMembership(ssdp.ip);
		this.sock.setMulticastTTL(2);
	}.bind(this));
	
	this.inMSearch = function (st, rInfo) {
		
		var peer = rInfo.address;
		var port = rInfo.port;
		
		if (st[0] === '"') st = st.slice(1, -1);
		
		for (usn in this.usn) {
			udn = this.usn[usn];
			
			if (st === 'ssdp:all' || usn == st) {
				var header = {
					ST             : usn,
					USN            : udn,
					LOCATION       : this.httpHost + '/device.xml',
					'CACHE-CONTROL': this.header.cache,
					DATE           : new Date().toUTCString(),
					SERVER         : this.header.server,
					EXT            : ''
				};
				
				var buf = new Buffer(this.getSSDPHeader('200 OK', header, true));
				
				util.log('Sending a 200 OK for an m-search to ' + peer + ':' + port);
				
				//util.log(buf.toString());
				
				this.sock.send(buf, 0, buf.length, port, peer);
			}
		}
	}
	
	process.on('exit', function () { this.close; } );
	
	this.addUSN = function (device) {
		this.usn[device] = ssdp.sig + '::' + device;
	}
	
	this.parseMessage = function (msg, rInfo) {
		
		var type = msg.toString().split('\r\n').shift();
		
		// HTTP/#.# ### Response
		if (type.match(/HTTP\/(\d{1})\.(\d{1}) (\d+) (.*)/))
			this.parseResponse(msg, rInfo);
		else
			this.parseCommand(msg, rInfo);
	}
	
	this.parseCommand = function parseCommand(msg, rInfo) {
		
		var lines  = msg.toString().split('\r\n');
		var type   = lines.shift().split(' ');
		var method = type[0];
		var uri    = type[1];
		
		var header = {};
		
		for (ix in lines) {
			var line = lines[ix];
			
			if (line.length < 1) continue;
			var vv = line.match(/^([^:]+):\s*(.*)$/);
			if (vv !== null) header[vv[1].toUpperCase()] = vv[2];
		}
		
		switch (method) {
			case 'NOTIFY':
				
				switch (header.NTS) {
					case 'ssdp:alive':
						this.emit('advertise-alive', header);
						break;
					
					case 'ssdp:byebye':
						this.emit('advertise-bye', header);
						break;
					
					default:
						util.log('############### Notify unhandled!');
				}
				
				break;
				
			case 'M-SEARCH':
				util.log('SSDP M-SEARCH: for (' + header.ST + ') from (' + rInfo.address + ':' + rInfo.port + ')');
				
				if (!header.MAN) return;
				if (!header.MX) return;
				if (!header.ST) return;
				this.inMSearch(header.ST, rInfo);
				
				break;
				
			default:
				util.log("Unknown message: \r\n" + msg);
		}
	}
	
	this.parseResponse = function parseResponse(msg, rInfo) {
		
		this.emit('response', msg, rInfo);
		/*util.log('Parsing a response!');
		util.log(msg.toString());*/
	}
	
	this.search = function search(st) {
		
		require('dns').lookup(os.hostname(), function (err, ipAddress) {
			
			this.sock.bind(0, ipAddress);
			
			var header = {
				HOST: ssdp.ipport,
				ST  : st,
				MAN : '"ssdp:discover"',
				MX  : 3
			};
			
			var buf = new Buffer(this.getSSDPHeader('M-SEARCH', header));
			
			//util.log(buf.toString());
			
			this.sock.send(buf, 0, buf.length, ssdp.port, ssdp.ip);
		}.bind(this));
	}
	
	this.server = function (proto, host, port) {
		
		this.httpHost = proto + '://' + host + ':' + port;
		
		this.usn[ssdp.sig] = ssdp.sig;
		
		this.sock.bind(ssdp.port, ssdp.ip);
		
		// Shut down.
		this.advertise(false);
		setTimeout(this.advertise.bind(this), 1000, false);
		
		// Wake up.
		setTimeout(this.advertise.bind(this), 2000);
		setTimeout(this.advertise.bind(this), 3000);
		
		// Ad loop.
		setInterval(this.advertise.bind(this), 5000);
	}
	
	this.close = function (callback) {
		
		this.advertise(false);
		
		setTimeout(function() {
			this.advertise(false);
			this.sock.close();
		}.bind(this), 1000);
		
		callback && setTimeout(callback, 1500);
	}
	
	this.advertise = function (alive) {
		
		if (!this.sock) return;
		
		if (typeof alive === 'undefined') alive = true;
		
		for (usn in this.usn) {
			var header = {
				HOST: ssdp.ipport,
				NT  : usn,
				NTS : (alive ? 'ssdp:alive' : 'ssdp:byebye'),
				USN : this.usn[usn]
			}
			
			if (alive) {
				header.LOCATION         = this.httpHost + '/device.xml';
				header['CACHE-CONTROL'] = this.header.cache;
				header.SERVER           = this.header.server;
			}
			
			var buf = new Buffer(this.getSSDPHeader('NOTIFY', header));
			
			//util.log(buf.toString());
			
			this.sock.send(buf, 0, buf.length, ssdp.port, ssdp.ip);
		}
	}
	
	this.getSSDPHeader = function (mes, header, isResponse) {
		
		var result = '';
		
		if (isResponse) {
			result = 'HTTP/1.1 ' + mes + '\r\n';
		} else {
			result = mes + ' * HTTP/1.1\r\n';
		}
		
		for (var i in header) {
			result += i + ': ' + header[i] + '\r\n';
		}
		
		result += '\r\n';
		
		return result;
	}
}

util.inherits(SSDP, events.EventEmitter);
exports.SSDP = SSDP;