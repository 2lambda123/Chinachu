/*!
 *  Chinachu SSDP Module (node-chinachu-ssdp)
 *
 *  Copyright (c) 2013 Yuki KAN and Chinachu Project Contributors
 *  http://chinachu.akkar.in/
 *
 *  forked from: node-ssdp by Nicholas Libby
 *  http://www.xedecimal.net/
 *  https://bitbucket.org/Xedecimal
 *  https://bitbucket.org/Xedecimal/node-ssdp
**/

var os     = require('os');
var dgram  = require('dgram');
var events = require('events');
var util   = require('util');

var ssdp = {
	ip  : '239.255.255.250',
	port: 1900,
	uuid: '49ee272d-f140-4cf0-a8cf-b7caa23ff772'
};

ssdp.ipport = ssdp.ip + ':' + ssdp.port;
ssdp.sig    = 'uuid:' + ssdp.uuid;

function SSDP() {
	if (!(this instanceof SSDP)) return new SSDP();
	
	events.EventEmitter.call(this);
	
	this.header = {
		host  : ssdp.ipport,
		cache : 'max-age=1800',
		server: [os.platform() + '/' + os.release(), 'UPnP/1.0', 'Chinachu-SSDP/0.0.1'].join(' ')
	};
	
	this.usns = {};
	
	// Configure socket for either client or server.
	this.sock = dgram.createSocket('udp4');
	
	this.sock.on('error', function () {
		util.log('############### Got an error!');
	});
	
	this.sock.on('message', function onMessage(msg, rinfo) {
		
		this.parseMessage(msg, rinfo);
	}.bind(this));
	
	this.sock.on('listening', function onListening() {
		
		var addr = this.sock.address();
		
		util.log('SSDP Listening on ' + addr.address + ':' + addr.port);
		
		this.sock.addMembership(ssdp.ip);
		this.sock.setMulticastTTL(2);
	}.bind(this));
	
	this.inMSearch = function (st, rinfo) {
		
		var peer = rinfo.address;
		var port = rinfo.port;
		
		if (st[0] === '"') st = st.slice(1, -1);
		
		for (usn in this.usns) {
			udn = this.usns[usn];
			
			if (st === 'ssdp:all' || usn == st) {
				var pkt = this.getSSDPHeader('200 OK', {
					ST             : usn,
					USN            : udn,
					LOCATION       : this.httpHost + '/device.xml',
					'CACHE-CONTROL': this.header.cache,
					DATE           : new Date().toUTCString(),
					SERVER         : this.header.server,
					EXT            : ''
				}, true);
				
				util.log('Sending a 200 OK for an m-search to ' + peer + ':' + port);
				
				pkt = new Buffer(pkt);
				this.sock.send(pkt, 0, pkt.length, port, peer);
			}
		}
	}
	
	process.on('exit', function () { this.close; } );
	
	this.addUSN = function (device) {
		this.usns[device] = ssdp.sig + '::' + device;
	}
	
	this.parseMessage = function (msg, rinfo) {
		
		var type = msg.toString().split('\r\n').shift();
		
		// HTTP/#.# ### Response
		if (type.match(/HTTP\/(\d{1})\.(\d{1}) (\d+) (.*)/))
			this.parseResponse(msg, rinfo);
		else
			this.parseCommand(msg, rinfo);
	}
	
	this.parseCommand = function parseCommand(msg, rinfo) {
		
		var lines  = msg.toString().split("\r\n");
		var type   = lines.shift().split(' ');
		var method = type[0];
		var uri    = type[1];
		
		var heads = {};
		
		for (ix in lines) {
			var line = lines[ix];
			
			if (line.length < 1) continue;
			var vv = line.match(/^([^:]+):\s*(.*)$/);
			heads[vv[1].toUpperCase()] = vv[2];
		}
		
		switch (method) {
			case 'NOTIFY':
				// Device coming to life.
				if (heads['NTS'] === 'ssdp:alive') {
					this.emit('advertise-alive', heads);
				}
				// Device shutting down.
				else if (heads['NTS'] === 'ssdp:byebye') {
					this.emit('advertise-bye', heads);
				}
				else util.log('############### Notify unhandled!');
				break;
				
			case 'M-SEARCH':
				util.log('SSDP M-SEARCH: for (' + heads['ST'] + ') from (' + rinfo['address'] + ':' + rinfo['port'] + ')');
				if (!heads['MAN']) return;
				if (!heads['MX']) return;
				if (!heads['ST']) return;
				this.inMSearch(heads['ST'], rinfo);
				break;
				
			default:
				util.log("Unknown message: \r\n" + msg);
		}
	}
	
	this.parseResponse = function parseResponse(msg, rinfo) {
		
		this.emit('response', msg, rinfo);
		/*util.log('Parsing a response!');
		util.log(msg.toString());*/
	}
	
	this.search = function search(st) {
		
		require('dns').lookup(require('os').hostname(), function (err, add) {
			
			this.sock.bind(0, add);
			
			var pkt = this.getSSDPHeader('M-SEARCH', {
				HOST: ssdp.ipport,
				ST  : st,
				MAN : '"ssdp:discover"',
				MX  : 3
			});
			
			pkt = new Buffer(pkt);
			
			util.log(pkt.toString());
			
			this.sock.send(pkt, 0, pkt.length, ssdp.port, ssdp.ip);
		}.bind(this));
	}
	
	this.server = function (proto, host, port) {
		
		this.httpHost = proto + '://' + host + ':' + port;
		
		this.usns[ssdp.sig] = ssdp.sig;
		
		this.sock.bind(ssdp.port, ssdp.ip);
		
		// Shut down.
		this.advertise(false);
		setTimeout(this.advertise.bind(this), 1000, false);
		
		// Wake up.
		setTimeout(this.advertise.bind(this), 2000);
		setTimeout(this.advertise.bind(this), 3000);
		
		// Ad loop.
		setInterval(this.advertise.bind(this), 5000);
	}
	
	this.close = function (callback) {
		
		this.advertise(false);
		
		setTimeout(function() {
			this.advertise(false);
			this.sock.close();
		}.bind(this), 1000);
		
		callback && setTimeout(callback, 1500);
	}
	
	this.advertise = function (alive) {
		
		if (!this.sock) return;
		if (typeof alive === 'undefined') alive = true;
		
		for (usn in this.usns) {
			udn = this.usns[usn];
			
			var out = 'NOTIFY * HTTP/1.1\r\n';
			heads = {
				HOST: ssdp.ipport,
				NT  : usn,
				NTS : (alive ? 'ssdp:alive' : 'ssdp:byebye'),
				USN : udn
			}
			if (alive) {
				heads['LOCATION']      = this.httpHost + '/device.xml';
				heads['CACHE-CONTROL'] = 'max-age=1800';
				heads['SERVER']        = this.header.server;
			}
			out = new Buffer(this.getSSDPHeader('NOTIFY', heads));
			this.sock.send(out, 0, out.length, ssdp.port, ssdp.ip);
		}
	}
	
	this.getSSDPHeader = function (head, vars, res) {
		
		if (res == undefined) res = false;
		if (res) ret = "HTTP/1.1 " + head + "\r\n";
		else ret = head + " * HTTP/1.1\r\n";
		for (n in vars) ret += n+": " + vars[n] + "\r\n";
		return ret + "\r\n";
	}
}

util.inherits(SSDP, events.EventEmitter);
exports.SSDP = SSDP;